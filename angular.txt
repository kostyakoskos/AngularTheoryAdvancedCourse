x`xjs в определенный момент стало сложно поддерживать, поэтому на его смену пришли разные frontend фреймворки.2
Представлен google в 2012 году. Структура mvc. Нацелена на динамическое обновление страниц.
angular поддерживается на мобильных приложениях, десктопных, веб.
angular использует typescript.
Минусы angular:
1. Много весит
2. Нужно знать typescript и библиотеку rx.js .
Angular следует исопльзовать на средних и больших проектах.
Angular для разработки одностраничных приложений. 
Пример - это gmail. Sumsung, paypal, dauche bank.
Angular поддерживает unit тестирование и сквозное тестирование.

bindings- для связки. Явно указать angular что будет динамический аттрибут. binding есть двухстронний. Binding может быть автоматический, но не для js, объектов, чисел. Автоматический binding только для строк.
Например, в .html сделали новую кнопку. <button [disabled]='disabled'>
В .ts файле, в методе ngOnInit сделали setTimeout и поле disabled делае true спустя 4 c.

Incremental DOM используется компанией Google для внутренних нужд. Его основная идея такова.
Каждый компонент компилируется в набор инструкций, которые создают DOM-деревья и непосредственно обновляют их при изменении данных.

!Перегрузки кострукторов в angular нет!

Модули Angular:
1. FormsModule - для работы с формой.
2. HttpClientModule - для работы с http.
3. BrowserModyle - для работы в браузере.
4. Свои модули

Разновидности скобок:
[] - пишем в .html, говорим что будет изменяться какая-то переменная.
() - пишем в .html, берем какую-то интеракцию от шаблона к компоненту.
[()] - для двухстороннего связывания.

[(ngModel)]- для работы с формой, например для передачи информации из/в форму. Т.е. писать @Input при этом не надо.

Event binding - из html в typescript.

$event - передать событие в .html . это native event и angular будет сам его передавать.

#myInput - ссылка на данный input

* данная директива сигнализирует, что надо менять на html.
Т.е. получается что через * можно указать if в файле component.html . For также можно указать.

trim - пустая или нет строка.

Можно динамически добавлять класс.

Есть директивы *ngIf, *ngFor, *ngSwitch- меняют html - структрурные директивы.
На самом деле, * обозначает, что создается ng-template, где выполняется binding[]. Т.е. каждый *ngIf оборачивается в ng-template.чёё

Декортаоры:
1. @HostListene - слушать событие, например клик.	
2. @Input, @Output - передача между родительским компонентом и дочерним компонентом.
3. @HostBinding
4. @Injectable - чтобы можно было добавить параметры в конструктор. Если данного декоратора не будет, то в сервис мы не сможем ничего инжектировать. Является частью механизма DI.
5. @Output - чтобы выводить какие-то события, например.
6. @ViewChild() - 
7. @ContentChild() - Когда в .html рендерим компонет <app>Тут, что-то пишем, доступ к этому надо получить в .ts файла. </app> . В .ts файле пишем ViewChild

Виды событий:
1. Click
2. mouseenter - мышь зашла на данный элемент
3. mouseleave - мышь покаинула элемент.

Виды директив:
1. routerlink

Запуск  ng serve --o
ng g c post-component --skipTests - создание компонента. ng generate component
ng g d style2 --skipTests - Создание директивы.

ctrl + d - выбрать несколько
ctrl + shift + b - меню сверху вызвать

Как связать back-end и front-end? 
1. Services.addCors();
2.  app.UseCors(options => 
                options.WithOrigins("http://localhost:4200")
                    .AllowAnyMethod()
                    .AllowAnyHeader()
                );

Точка входа- main.ts .

Компоненты, директивы, модули - это классы.

Как создать компоненты в angular? В .ts файле пишем export класс и @Component.

Пайпы - позволяют трансформировать дату и время в нужный формат.   {{ now | date }} - тут отфрматировали в pipe date.\
Также пайпы позволяют филтровать список элементов, например по какому-то полю.

Создание директивы. Скобки [] обязательны.
@Directive({
selector:'[app-style]'
})

Сервисы - это отдельные классы в angular, которые позволяют работать с данными. Позволяют связывать данные с отображением. Сервисы создаются для стороннего исопользования.
Как создавать сервисы? Два варианта:
1.Создать класс. Зарегистировать класс в @NgModule provider или написать декоратор @Injectable с параметром providedIn. 
Т.е. либо мы регистрируем сервис в NgModule, либо в декораторе пишем providedIn.
2. ng g s serices/local-counter --skipTests
Область вилимости сервисов. Сервисы можно создать на самом нижнем(большом, глобальном) уровне root. Когда компоненту требуется сервис, сначала проверяется root, а потом выше смотрится.
Если есть 2 сервиса в root и где-то ещё сервис с таким же названием, то будет использован сервис который находится в root, дальше смотреть не будем.
Как правильно используют глобальную видимость? Создают сервис на уровне root, который используют в разных местах и получают необходимые данные. Подобный подход очень удобный.

Как сделать dependency injection в angular? Необходимо реализовать метод конструктора. 

Модификаторы доступа: public private protected. Причем, модификаторы доступа работают немного по другому в angular 12, например private. Лучше вместо него писать public.

Есть 2 подхода к созданию форм: reactive подход и шаблонный.
Реактивные формы- мы делаем их программно.
Класс Validators- для валидирования формы. Например, в классе Validators есть проверка на email, длинна и тд.

Хуки Angular:
1. ngOnChanges: вызывается каждый раз, когда изменяется свойство ввода, привязанного к данным. В первый раз он вызывается перед обработчиком ngOnInit. Этот хук получает объект SimpleChanges, который содержит предыдущие и текущие значения для свойств ввода с привязкой к данным. Он вызывается часто, поэтому рекомендуем ограничить объем выполняемой им обработки.
2. ngOnInit: вызывается один раз при инициализации компонента.
3. ngDoCheck: этот хук можно использовать вместо ngOnChanges для отслеживания изменений, которые Angular не обнаруживает. Он вызывается при каждом цикле обнаружения изменений, поэтому для производительности важно свести работу этого хука к минимуму.
4. ngAfterContentInit: вызывается после проецирования контента в компоненте.
5. ngAfterContentChecked: вызывается после проверки проецируемого контента.
6. ngAfterViewInit: вызывается после инициализации представления родительского или дочернего компонента.
7. ngAfterViewChecked: вызывается после проверки представления родительского или дочернего компонента.
8. ngOnDestroy: вызывается один раз при уничтожении компонента. Этот хук хорошо подходит для очистки и отмены подписки на наблюдаемые объекты.

<router-outlet></router-outlet> - нужен чтобы angualr понимал что надо перерисовывать, добавлять компонент. Т.е. если мы не укажем этот компонент, то будет рисоваться и по адресу /about и /home одно и тоже.
Пишем router-outlet, чтобы angular понимал куда ему рендерить детей.

Перерисовывать всю страницу не надо. !Вместо href пишем routerLink! - для того чтобы не перезагружать полностью страницу. Это single page application.

Синтаксис /:id - id это название параметра, которое генерируется автоматически.

+params.id - переводит в number, typescript. parseint модем писать также, но + удобнее.

@NgModule({
declarations: классы представлений (view classes), которые принадлежат модулю. Angular имеет три типа классов представлений: компоненты (components), директивы (directives), каналы (pipes)
exports: набор классов представлений, которые должны использоваться в шаблонах компонентов из других модулей
imports: другие модули, классы которых необходимы для шаблонов компонентов из текущего модуля
providers: классы, создающие сервисы, используемые модулем
bootstrap: корневой компонент, который вызывается по умолчанию при загрузке приложения
})

Lazy loading- загрузка только необходимых модулей. Т.е. по молчанию мы грузим все модули. Но можно загружать страницу about, только если мы её открываем.
Пример работы:
//{path:'about', loadChildren: './about-page/about-extra-page/about-page.module#AboutPageModule'},
// new sintacsis
{path: 'about', loadChildren: () => import('./about-page/about-extra-page/about-page.module').then(m => m.AboutPageModule)},
Можно использовать lazy loading с параметрами. Например, после загрузки самых необходимых модулей, будут загружаться в фоновом режиме отдельные модули. 
 imports: [RouterModule.forRoot(routes, {preloadingStrategy: PreloadAllModules})]

Динамические компонеты- те, которые может создавать в typescript.

[ngClass] - динамические классы. В .html можем задавать динамически классы с использованием if.

<ng-template> - специальный html тег в angular, который при компиляции не будет появляться в DOM дереве. Применяется только при разработке.

Анимации. webAnimationApi- делать сложные анимации с использованием js. Находится в модуле BrowserAnimationsModule.
[@box]="boxState" - binding для анимаций, использование @ обязательно. После равно пишем название состояния.
transition - отвчает за процесс анимации. Можем задать время, например, за 2000 мс цвет квадрата поменяется на другой. Произойдет это плавно.
ease-in-out - для плавной кофигурации. 

!В angular есть геттеры и сеттеры!

Интерсепторы- нужны для того, чтобы в общем месте обрабатывать потенциальные ошибки с сервера. К каждому запросу добавляем токен. Интерсепторы необходимо регистрировать в главном модуле.

PWA - Progressive Web App, технология, трансформирующая сайт в приложение.
ng add @angular/pwa - подключение pwa в проект.
Появляется файлы: .webmanifest, ngsw-config.json
npm install -g httpserver - установить http сервер.

Вопросы:
1. Что такое Guards? Guards - это такая сущность в angular, который решает можно ли загрузить компонент на страницу(т.е. можно ли пользователю войти как админ, например).
2. Что такое модули? Модули - некотрый набор сущностей, как строительные блоки в доме. import {} from '@angular/core'
@NgModule{
imports - другие модули для поделючения
provider - для необходимых сервисов
declarations - для компонентов, директивов, пайпов
exports - публичные сущности, которые доступны в этом модуле.
bootstrap - тот компонет,  с которго загружаем модуль.
}
3. Отличие angularjs и angular.
angularjs это более старая версия. В angular используется typescript, es6. Потом появился angular 2. Сейчас 12 версия angular. 
4. Что такое компоненты? Компонет- базовый, строительный блок.
5. Что обязательно у Component? Template или templateUrl. Selector необязательно.
6. Отличие модуля от компонента. Компоненты контролируют html. Модули состоят из 1-го и более компонентов.
7. Что такое сервисы и зачем они нужны? Сервисы в angular хранят данные. Сервисы не взаимодействуют с html, а только работают с данными. Можно регистрировать 1 сервис на все приложение
и использовать в нескольких компонентах.
8. Разница между *ngIf и [hidden]. ngIf убирает элемент из dom дерева. А [hidden] скрывает отображение просто. Hidden не меняет html.
9. Разница меджду @Component и @Directive? Директивы задают модель поведения(добавление стилей, событий) работают в рамках компонента. Компоненты работают в среде html. 
10. 
11. Разница между структурной и аттрибут директивой. *ngIf *ngFor - могут менять html шаблон. *- для обозначения структурной директивы. Аттрибут директива не меняет html. 
Имеет определнное поведение. Пример- ngStyle и ngClass. 
12. Что такое Observables? Это паттерн проектирования, который используется за счет библиотеки rxjs. Если мы подписываемся на уведомление, и оно приходит сразу в нужных местах.
13. Что такое интерполяция? Это просто синтаксис, который позволяет передавать динамические элементы в шаблон. Например {{ }}. Можно менять на любой синтаксис.
14. Разница между Promise и Observable? Оба этих класса работают с асинхронным кодом. Promise работает с единственным событием. элементы в Promise нельзя отменять. 
Асинхронные события, которые мы оборачиваем в Promise- будут выполнены. И не важно, есть блок then или нет. Observable - если нет никаких подписчиков, то события не будут выполняться.
15. Разница constructor и ngOnInit? Конструктор вызывается когда создается экземпляр класса. ngOnInit - компонент готов к работе. В ngOnInit делаем всю работу, например, привязываем компонет. 
Привязывать компонент в контрукторе нельзя. 
16. Что такое реактивное программирование в angular. Реактивное программирование - это программирование с асинхронными, различными datastream. 
17. Зачем использовать spy в тестах? Фреймворк jasmin - для тетсирования angular. Фунция spy помогает следить за методом. Т.е. можем вызвать fakeFunc и следить за ней.
18. Что такое testBad? Можем создавать модули, компоненты, интеграционное тестирование.
19. Что такое Protractor? Нужен для e2e тестирования. Запуск тестов в реальном браузере и показывает как пользователь себя ведет.
20. Как сделать ресайз элементов? Чтобы сделать ресайз, нужно поработать с document, window. 
@HostLisener('window:resize', ['$event'])
onResize(event){
event.target.innerWidth;
}
21. Что такое AOT? Ahead of time compiler. Браузер не понимает директивы ngIf, ngFor. AOT подготавливает весь html. При исопльзовании AOT приложениии быстрее загружается.
Не нужна клиентская компиляция. Это техника, позволяющее заранее подготовить angular приложение, чтобы оно было максимально производительным.
22. Что такое ActivatedRoute? Для того, чтобы получить доступ до текущего, активного роута, this. 
23. Что такое динамические компоненты? Это такие компоненты, которые что-то делают во время выполнения. Они зарегистрированы, определены, но шаблоне их нет.
В дом дерево динамически их добавляем.
24. Какие функции есть в RxJs? RxJS библиотека, позволяющая работать с observables. Можем фильтровать стрим, приводить их к определенному виду. Можно писать асинхронный код,
при этом можно писать как синхронный код.
25. Как переждавать параметры в pipe? Через символ : . Первый параметр в transform то значение.
26. Какие есть типы binding? 1. из компоненты в шаблон [], {{ интерполяция }} 2. События (). Байндит из шаблона в компонент. 3. Two way binding- любое изменение шаблона приводит к изменению модели данных и наоборот ([])
27. Что такое Life cycle hooks?(Что такое жизненный цикл и для чего он используется). Показывает, на каком этапе находится компонент.
constructor()
ngOnChanges() - вызывается, когда менятеся input значения. Если передаем от родителя что-то в компонент или директиву.
ngOnInit() - вызывается 1 раз, сразу после ngOnChanges. Вызывается когда компонент был проинициализирован и готов к использованию.
ngDoCkeck() - вызывается тогла, когда начинает свою работу changeDetection в angular. 
	ngAfterConteinIt
ngDestroy() - вызывается перед тем, когда компонент, директива уничтожаются. Нужен чтобы отписывались от observables.
28. Можно ли использовать jQuerry с angular? Можно. шНужно когда использовуем большой плагин на jquerry. 
29. Что такое interceptors? Нужны, чтобы в общем модуле обрабатывать ошибки с сервера. Чтобы к каждому запросу добавлять какой-то элемент, например, токен.
30. Что делает метод detect changes в тестах? Detect changes нужно форсированно вызывать. 
31. Почему нужно использовать render2? Renderer2 пождерживает абстрактный методы angular, выполенение не в дом ориентированных средах.
32. Зачем нужен zone.js, который присутсвует в ядре angular? zone.js - нужен для создатия своих оболочек вокруг асинхронных операций или функций в приложении, чтобы удобнее было следить за ними. Благодаря этому
работает механизм changeDtection() - закончились се асинхронные операции.
33. Что делает JIT? Just-In-time. Отличается от AOT тем, что он запускается в момента запуска приложения. Компилирует различные вещи на лету. Имеет доступ к оперативной памяти. Преобразует все в машинный код до того,
как программа страртовала.
34. Какие есть стратегии загрузки? Lazy loading. По умолчанию, как мы залогинилсь, preload.
35. Отличие incremental dom(исопльзуется в гугл) от virtual dom? Когда компилируем компоненты, они компилируются в набор инструкций. Подобные инструкции создают dom дерево, которое обновляется только в тех местах,
когда меняются какие-либо данные, но при этом это обычное дом дерево. React - каждый компонент создает новый виртульный дом, когда происходит этап рендеринга.
36. Зачем нужен процесс компиляции в angular? Браузер ест только html. Поэтому с помощью компиляции мы можем мделать html и отдать браузеру.
37. Разница между pure pipe and impure pipe? По умолчанию все pure pipe. Pure pipe вызывает метод transform. Примитивные значения строки числа, булеан, ссылка. Impure pipe вызывается всегда, 
когда работает changeDetection. 
38. Разница между behaviourSubject и Observable? С помощью Observable можем подписываться на стрим, subject. behaviourSubject- это частный случай subject, может создавать стримы, подписываться на subject,
задавать новые значения в stream. 
39. Как следить за изменениями входящих свойств? В компонент, директива. Можем использовать ngOnChanges. В angularJS есть концеция watch. Можно испольщовать сеттеры. Пишем input декоратор к какому-то значению и делаем его сетером.
40. Tree shaking? 




Декораторы динамически подключают дополнительное поведение к объекту. Они помечают класс и предоставляют конфигурационные метаданные.

@NgModule может содержать следующие параметры:
providers - список инжектируемых объектов, которые добавляются в этот модуль
declarations - компоненты, директивы и пайпы, принадлежащие этому модулю
imports - модули, которые экспортируются декларируемыми и доступны в шаблоне этого модуля
exports - компоненты, директивы и пайпы, которые объявлены декларируемыми, и могут быть им пользованы в шаблоне любого компонента, которые принадлежит NgModule импортирующему их.
entryComponent - компилируемые компоненты при определении NgModule, для динамической загрузки в view.
bootstrap - компоненты, которые загружаются при загрузке этого модуля, автоматически добавляются в entryComponent.
schemas - набор схем, объявляющих разрешенные элементы в MgModules
id - имя или путь, уникальный идентификатор этого NgModule в getModuleFactory. Если не заполнять - не будет там зарегистрирован.
jit - если true, то этот модуль будет пропущен компилятором AOT и всегда будет компилироваться JIT.
@Component может содержать следующие параметры:
changeDetection - стратегия обнаружения изменений, используемая для этого компонента
viewProviders - инжектируемые объекты, которые видны DOM children этого компонента.
moduleId - id модуля, к которому относится компонент.
templateUrl - относительный путь или абсолютный URL к шаблону компонента.
template - инлайн шаблон для этого компонента.
styleUrls - один и более путь до файла, содержащего CSS, абсолютный или относительный.
styles - инлайн CSS, используемые в этом компоненте.
animations - один и более вызовов анимации trigger(), содержащих state() и transition().
encapsulation - правила инкапсуляции для шаблона и CSS.
interpolation - переопределение базовых знаков интерполяции.
entryComponents - компоненты, которые должны быть скомпилированы вместе с этим компонентом. Для каждого упомянутого здесь компонента создается ComponentFactory и сохраняется в ComponentFactoryResolver.
preserveWhitespaces - при значении true удаляются потенциально лишние пробелы из скомпилированного шаблона.
@Directive может содержать следующие параметры:
selector - CSS-селектор, который идентифицирует эту директиву в шаблоне и запускает создание этой директивы.
inputs - свойство для определения значение @Input() параметра. Значение из inputs можно сразу использовать в шаблоне, без объявления переменной в классе. Пример объявления: inputs: ['name', 'id: id-from-parent']. Значение в inputs массиве может состоять из:
directiveProperty - наименование свойства @Input, которое будет использоваться в дочернем компоненте для вывода в шаблоне и использования в самом классе.
bindingProperty - наименование свойства, из которого будет производится чтение и запись в directiveProperty. Не обязательное. При отсутсвии параметра значение будет браться из directiveProperty
@Injectable может содержать следующие параметры:
providedIn - определяет, где будет заинжектировано, либо, если объявлено "root" распространится на все приложение.
@Pipe может содержать следующие параметры:
name - имя пайпа, которое будет использовано в шаблоне.
pure - если true, то пайп считается "чистым", и метод transform() вызовется только при изменении его входных агрументов. По умолчанию стоит true.



















